
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>protobuf: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">41.neocities.org/protobuf/protobuf.go (90.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package protobuf

import (
   "errors"
   "fmt"
   "google.golang.org/protobuf/encoding/protowire"
   "slices"
)

func (m Message) GoString() string <span class="cov8" title="1">{
   data := []byte("protobuf.Message{\n")
   for _, f := range m </span><span class="cov0" title="0">{
      data = fmt.Appendf(data, "{%v, %#v},\n", f.Number, f.Value)
   }</span>
   <span class="cov8" title="1">data = append(data, '}')
   return string(data)</span>
}

func get[V Value](m Message, num Number) func() (V, bool) <span class="cov8" title="1">{
   var index int
   return func() (V, bool) </span><span class="cov8" title="1">{
      for index &lt; len(m) </span><span class="cov8" title="1">{
         index++
         value0, ok := m[index-1].Value.(V)
         if ok </span><span class="cov8" title="1">{
            return value0, true
         }</span>
      }
      <span class="cov0" title="0">return *new(V), false</span>
   }
}

func (m Message) GetBytes(num Number) func() (Bytes, bool) <span class="cov8" title="1">{
   var index int
   return func() (Bytes, bool) </span><span class="cov8" title="1">{
      for index &lt; len(m) </span><span class="cov8" title="1">{
         index++
         switch value0 := m[index-1].Value.(type) </span>{
         case Bytes:<span class="cov8" title="1">
            return value0, true</span>
         case *LenPrefix:<span class="cov0" title="0">
            return value0.Bytes, true</span>
         }
      }
      <span class="cov0" title="0">return nil, false</span>
   }
}

func (m Message) Get(num Number) func() (Message, bool) <span class="cov8" title="1">{
   var index int
   return func() (Message, bool) </span><span class="cov8" title="1">{
      for index &lt; len(m) </span><span class="cov8" title="1">{
         index++
         switch value0 := m[index-1].Value.(type) </span>{
         case Message:<span class="cov8" title="1">
            return value0, true</span>
         case *LenPrefix:<span class="cov0" title="0">
            return value0.Message, true</span>
         }
      }
      <span class="cov0" title="0">return nil, false</span>
   }
}

func (m *Message) Unmarshal(data []byte) error <span class="cov8" title="1">{
   for len(data) &gt;= 1 </span><span class="cov8" title="1">{
      num, wire_type, size := protowire.ConsumeTag(data)
      err := protowire.ParseError(size)
      if err != nil </span><span class="cov0" title="0">{
         return err
      }</span>
      <span class="cov8" title="1">data = data[size:]
      // google.golang.org/protobuf/encoding/protowire#ConsumeFieldValue
      switch wire_type </span>{
      case protowire.BytesType:<span class="cov8" title="1">
         v, size := protowire.ConsumeBytes(data)
         err := protowire.ParseError(size)
         if err != nil </span><span class="cov8" title="1">{
            return err
         }</span>
         <span class="cov8" title="1">*m = append(*m, Field{
            num, unmarshal(v),
         })
         data = data[size:]</span>
      case protowire.Fixed32Type:<span class="cov8" title="1">
         v, size := protowire.ConsumeFixed32(data)
         err := protowire.ParseError(size)
         if err != nil </span><span class="cov0" title="0">{
            return err
         }</span>
         <span class="cov8" title="1">*m = append(*m, Field{
            num, I32(v),
         })
         data = data[size:]</span>
      case protowire.Fixed64Type:<span class="cov8" title="1">
         v, size := protowire.ConsumeFixed64(data)
         err := protowire.ParseError(size)
         if err != nil </span><span class="cov0" title="0">{
            return err
         }</span>
         <span class="cov8" title="1">*m = append(*m, Field{
            num, I64(v),
         })
         data = data[size:]</span>
      case protowire.VarintType:<span class="cov8" title="1">
         v, size := protowire.ConsumeVarint(data)
         err := protowire.ParseError(size)
         if err != nil </span><span class="cov0" title="0">{
            return err
         }</span>
         <span class="cov8" title="1">*m = append(*m, Field{
            num, Varint(v),
         })
         data = data[size:]</span>
      default:<span class="cov8" title="1">
         return errors.New("cannot parse reserved wire type")</span>
      }
   }
   <span class="cov8" title="1">return nil</span>
}

// protobuf.dev/programming-guides/encoding#cheat-sheet
type I64 uint64

// protobuf.dev/programming-guides/encoding#cheat-sheet
type LenPrefix struct {
   Bytes   Bytes
   Message Message
}

// protobuf.dev/programming-guides/encoding#cheat-sheet
type Message []Field

// protobuf.dev/programming-guides/encoding#cheat-sheet-key
type Number = protowire.Number

// protobuf.dev/programming-guides/encoding#cheat-sheet
type Value interface {
   Append([]byte, Number) []byte
   fmt.GoStringer
}

// protobuf.dev/programming-guides/encoding#cheat-sheet
type Varint uint64

// protobuf.dev/programming-guides/encoding#cheat-sheet
type Bytes []byte

func (b Bytes) GoString() string <span class="cov8" title="1">{
   return fmt.Sprintf("protobuf.Bytes(%q)", []byte(b))
}</span>

// protobuf.dev/programming-guides/encoding#cheat-sheet-key
type Field struct {
   Number Number
   Value  Value
}

// protobuf.dev/programming-guides/encoding#cheat-sheet
type I32 uint32

func (b Bytes) Append(data []byte, num Number) []byte <span class="cov8" title="1">{
   data = protowire.AppendTag(data, num, protowire.BytesType)
   return protowire.AppendBytes(data, b)
}</span>

func (i I32) GoString() string <span class="cov8" title="1">{
   return fmt.Sprintf("protobuf.I32(%v)", i)
}</span>

func (i I32) Append(data []byte, num Number) []byte <span class="cov8" title="1">{
   data = protowire.AppendTag(data, num, protowire.Fixed32Type)
   return protowire.AppendFixed32(data, uint32(i))
}</span>

func (i I64) GoString() string <span class="cov8" title="1">{
   return fmt.Sprintf("protobuf.I64(%v)", i)
}</span>

func (i I64) Append(data []byte, num Number) []byte <span class="cov8" title="1">{
   data = protowire.AppendTag(data, num, protowire.Fixed64Type)
   return protowire.AppendFixed64(data, uint64(i))
}</span>

func (m *Message) AddVarint(num Number, v Varint) <span class="cov8" title="1">{
   *m = append(*m, Field{num, v})
}</span>

func (m *Message) AddI64(num Number, v I64) <span class="cov8" title="1">{
   *m = append(*m, Field{num, v})
}</span>

func (m *Message) AddI32(num Number, v I32) <span class="cov8" title="1">{
   *m = append(*m, Field{num, v})
}</span>

func (m *Message) AddBytes(num Number, v Bytes) <span class="cov8" title="1">{
   *m = append(*m, Field{num, v})
}</span>

func (p *LenPrefix) GoString() string <span class="cov8" title="1">{
   data := []byte("&amp;protobuf.LenPrefix{\n")
   data = fmt.Appendf(data, "%#v,\n", p.Bytes)
   data = fmt.Appendf(data, "%#v,\n", p.Message)
   data = append(data, '}')
   return string(data)
}</span>

func (p *LenPrefix) Append(data []byte, num Number) []byte <span class="cov8" title="1">{
   data = protowire.AppendTag(data, num, protowire.BytesType)
   return protowire.AppendBytes(data, p.Bytes)
}</span>

func (m Message) Marshal() []byte <span class="cov8" title="1">{
   var data []byte
   for _, field0 := range m </span><span class="cov8" title="1">{
      data = field0.Value.Append(data, field0.Number)
   }</span>
   <span class="cov8" title="1">return data</span>
}

func (m Message) GetVarint(num Number) func() (Varint, bool) <span class="cov8" title="1">{
   return get[Varint](m, num)
}</span>

func (m Message) GetI64(num Number) func() (I64, bool) <span class="cov8" title="1">{
   return get[I64](m, num)
}</span>

func (m Message) GetI32(num Number) func() (I32, bool) <span class="cov8" title="1">{
   return get[I32](m, num)
}</span>

func (v Varint) GoString() string <span class="cov8" title="1">{
   return fmt.Sprintf("protobuf.Varint(%v)", v)
}</span>

func (m Message) Append(data []byte, num Number) []byte <span class="cov8" title="1">{
   data = protowire.AppendTag(data, num, protowire.BytesType)
   return protowire.AppendBytes(data, m.Marshal())
}</span>

func unmarshal(data []byte) Value <span class="cov8" title="1">{
   data = slices.Clip(data)
   if len(data) &gt;= 1 </span><span class="cov8" title="1">{
      var m Message
      if m.Unmarshal(data) == nil </span><span class="cov8" title="1">{
         return &amp;LenPrefix{data, m}
      }</span>
   }
   <span class="cov8" title="1">return Bytes(data)</span>
}

func (v Varint) Append(data []byte, num Number) []byte <span class="cov8" title="1">{
   data = protowire.AppendTag(data, num, protowire.VarintType)
   return protowire.AppendVarint(data, uint64(v))
}</span>

// wikipedia.org/wiki/Continuation-passing_style
func (m *Message) Add(num Number, v func(*Message)) <span class="cov8" title="1">{
   var m1 Message
   v(&amp;m1)
   *m = append(*m, Field{num, m1})
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
